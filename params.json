{
  "name": "Effetive java",
  "tagline": "",
  "body": "## concurrency 同步\r\n### avoid excessive synchronization 避免过度使用synchronization\r\nHere is an example,which implements an observable set wrapper.It allow clients to\r\nsubscribe to notifications when elements are added to the set.this is the *Observer* pattern.\r\nfor brevity`s, the class does not provide notifications when elements are removed from the set.\r\n\r\n这有一个观察着封装的set，它允许客户端订阅添加元素的通知，为了简介，没有提供移出元素的通知。\r\n\r\nObservers subscribe to notifications by invoking the addObserver method and unsubscribe by invoking\r\nthe removeObserver method. In both cases, an instance of the *callback* interface is passed to the method.\r\n\r\n观察者订阅调用addObserver，取消订阅调用removeObserver，两种操作的参数都回调接口。\r\n\r\n```\r\n\r\nimport java.util.*;\r\n\r\n/**\r\n * Created by why on 10/23/2016.\r\n */\r\npublic class ObservableSet0<E> extends HashSet<E> {\r\n    public ObservableSet0(Set<E> set) {\r\n        super(set);\r\n    }\r\n\r\n    private final List<SetObserver<E>> observers = new ArrayList<SetObserver<E>>();\r\n\r\n    public void addObserver(SetObserver<E> observer) {\r\n        synchronized (observers) {\r\n            observers.add(observer);\r\n        }\r\n    }\r\n\r\n    public boolean removeObserver(SetObserver<E> observer) {\r\n        synchronized (observers) {\r\n            return observers.remove(observer);\r\n        }\r\n    }\r\n\r\n    private void notifyElementAdded(E element) {\r\n        synchronized (observers) {\r\n            for (SetObserver<E> observer : observers)\r\n                observer.added(this, element);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public boolean add(E element) {\r\n        boolean added = super.add(element);\r\n        if (added)\r\n            notifyElementAdded(element);\r\n        return added;\r\n    }\r\n\r\n    @Override\r\n    public boolean addAll(Collection<? extends E> c) {\r\n        boolean result = false;\r\n        for (E element : c)\r\n            result |= add(element); // calls notifyElementAdded\r\n        return result;\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        ObservableSet0<Integer> set = new ObservableSet0<Integer>(new HashSet<Integer>());\r\n        set.addObserver(new SetObserver<Integer>() {\r\n            public void added(ObservableSet0<Integer> s, Integer e) {\r\n                System.out.println(e);\r\n            }\r\n        });\r\n        for (int i = 0; i < 100; i++)\r\n            set.add(i);\r\n    }\r\n\r\n    static class SetObserver<E> {\r\n        public void added(ObservableSet0<E> es, E element) {\r\n        }\r\n    }\r\n}\r\n\r\n```\r\nThe result will print 0 through 99.Now let`s try something els.Suppose we replace the addObserver call with one that\r\npasses an observer that prints the Integer value that was added to the set and removes itself if the value is 23.\r\n\r\n结果是打印0-99。我们试着做一些其他事，添加一个订阅者，打印数字，并在数字是23的时候移出自己。\r\n```\r\nimport java.util.*;\r\n\r\n/**\r\n * caes an  java.util.ConcurrentModificationException\r\n * Changing ArrayList to CopyOnWriteArrayList can solve this problem\r\n * <p>\r\n * Created by why on 10/23/2016.\r\n */\r\npublic class ObservableSet1<E> extends HashSet<E> {\r\n    public ObservableSet1(Set<E> set) {\r\n        super(set);\r\n    }\r\n\r\n    // fixme 2016-10-23 CopyOnWriteArrayList can solve this problem\r\n    private final List<SetObserver<E>> observers = new ArrayList<SetObserver<E>>();\r\n\r\n    public void addObserver(SetObserver<E> observer) {\r\n        synchronized (observers) {\r\n            observers.add(observer);\r\n        }\r\n    }\r\n\r\n    public boolean removeObserver(SetObserver<E> observer) {\r\n        synchronized (observers) {\r\n            return observers.remove(observer);\r\n        }\r\n    }\r\n\r\n    private void notifyElementAdded(E element) {\r\n        synchronized (observers) {\r\n            for (SetObserver<E> observer : observers)\r\n                observer.added(this, element);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public boolean add(E element) {\r\n        boolean added = super.add(element);\r\n        if (added)\r\n            notifyElementAdded(element);\r\n        return added;\r\n    }\r\n\r\n    @Override\r\n    public boolean addAll(Collection<? extends E> c) {\r\n        boolean result = false;\r\n        for (E element : c)\r\n            result |= add(element); // calls notifyElementAdded\r\n        return result;\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        ObservableSet1<Integer> set = new ObservableSet1<Integer>(new HashSet<Integer>());\r\n        set.addObserver(new SetObserver<Integer>() {\r\n            public void added(ObservableSet1<Integer> s, Integer e) {\r\n                System.out.println(e);\r\n                if (e == 23) {\r\n                    set.removeObserver(this);\r\n                }\r\n            }\r\n        });\r\n        for (int i = 0; i < 100; i++)\r\n            set.add(i);\r\n    }\r\n\r\n    static class SetObserver<E> {\r\n        public void added(ObservableSet1<E> es, E element) {\r\n        }\r\n    }\r\n}\r\n\r\n```\r\nYou might expect the program to print the numbers 0 through 23.But you get an unexpected *ConcurrentModificationException*.\r\nThe problem is that notifyElementAdded is in the process of iterating over the observers list when it invokes the observer`s\r\nadded method.he iteration in the notifyElementAddded method is in a synchronized block to prevent concurrent modification,\r\nbut is does not prevent the iterating thread itself from calling back into the observable set and modifying its observers list.\r\n\r\nNow let`s try something odd:Write an observer that attempts to unsubscribe, but instead of calling removeObserver directly,\r\nit engages the services of another thread to do the deed.This observer uses an executor service.\r\n```\r\n\r\nimport java.util.*;\r\nimport java.util.concurrent.ExecutionException;\r\nimport java.util.concurrent.ExecutorService;\r\nimport java.util.concurrent.Executors;\r\n\r\n/**\r\n * dead lock\r\n * <p>\r\n * This time we don’t get an exception; we get a deadlock. The background thread\r\n * calls s.removeObserver, which attempts to lock observers, but it can’t acquire\r\n * the lock, because the main thread already has the lock. All the while, the main\r\n * thread is waiting for the background thread to finish removing the observer, which\r\n * explains the deadlock.\r\n * Created by why on 10/23/2016.\r\n */\r\npublic class ObservableSet2<E> extends HashSet<E> {\r\n    public ObservableSet2(Set<E> set) {\r\n        super(set);\r\n    }\r\n\r\n    private final List<SetObserver<E>> observers = new ArrayList<SetObserver<E>>();\r\n\r\n    public void addObserver(SetObserver<E> observer) {\r\n        synchronized (observers) {\r\n            observers.add(observer);\r\n        }\r\n    }\r\n\r\n    public boolean removeObserver(SetObserver<E> observer) {\r\n        synchronized (observers) {\r\n            return observers.remove(observer);\r\n        }\r\n    }\r\n\r\n    private void notifyElementAdded(E element) {\r\n        synchronized (observers) {\r\n            for (SetObserver<E> observer : observers)\r\n                observer.added(this, element);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public boolean add(E element) {\r\n        boolean added = super.add(element);\r\n        if (added)\r\n            notifyElementAdded(element);\r\n        return added;\r\n    }\r\n\r\n    @Override\r\n    public boolean addAll(Collection<? extends E> c) {\r\n        boolean result = false;\r\n        for (E element : c)\r\n            result |= add(element); // calls notifyElementAdded\r\n        return result;\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        ObservableSet2<Integer> set = new ObservableSet2<Integer>(new HashSet<Integer>());\r\n        set.addObserver(new SetObserver<Integer>() {\r\n            public void added(ObservableSet2<Integer> s, Integer e) {\r\n                System.out.println(e);\r\n                if (e == 23) {\r\n                    ExecutorService executor =\r\n                            Executors.newSingleThreadExecutor();\r\n                    final SetObserver<Integer> observer = this;\r\n                    try {\r\n                        executor.submit(new Runnable() {\r\n                            public void run() {\r\n                                s.removeObserver(observer);\r\n                            }\r\n                        }).get();\r\n                    } catch (ExecutionException ex) {\r\n                        throw new AssertionError(ex.getCause());\r\n                    } catch (InterruptedException ex) {\r\n                        throw new AssertionError(ex.getCause());\r\n                    } finally {\r\n                        executor.shutdown();\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        for (int i = 0; i < 100; i++)\r\n            set.add(i);\r\n    }\r\n\r\n    static class SetObserver<E> {\r\n        public void added(ObservableSet2<E> es, E element) {\r\n        }\r\n    }\r\n}\r\n\r\n```\r\nThis time we don`t get an exception,we get a deadlock.The background thread calls s.removeObserve,which attempts to lock\r\n observers,bug it can not acquire the lock,because the main thread already has the lock.All the while,the main thread is\r\n waiting for the background thread to finish removing the observer,which explains the deadlock.\r\n\r\n这是一个人为的例子，因为我们没有必要再观察者中时候线程池。\r\n\r\n解决上面两种情况引起的问题，我们可以把方法调用移出同步块。就上面的例子，我们可以在notifyElementAdded方法中生产observer的快照，然后可以\r\n安全的去掉锁。这样上面两个例子都会完美运行。\r\n\r\n```\r\nprivate void notifyElementAdded(E element) {\r\n    List<SetObserver<E>> snapshot = null;\r\n    synchronized(observers) {\r\n        snapshot = new ArrayList<SetObserver<E>>(observers);\r\n    }\r\n    for (SetObserver<E> observer : snapshot)\r\n        observer.added(this, element);\r\n}\r\n```\r\n事实上有更好的方法，java 1.5提供的concurrent collection中的CopyOnWriteArrayList，就是为这个目的而生。当元素改变时，他会新复制一份\r\n完整的数据，对其他情况而言这种操作可能非常粗暴，但是非常适合保存observer，因为他改变的情况比较少。\r\n```\r\nprivate final List<SetObserver<E>> observers = new CopyOnWriteArrayList<SetObserver<E>>();\r\npublic void addObserver(SetObserver<E> observer) {\r\n    observers.add(observer);\r\n}\r\npublic boolean removeObserver(SetObserver<E> observer) {\r\n    return observers.remove(observer);\r\n}\r\nprivate void notifyElementAdded(E element) {\r\n    for (SetObserver<E> observer : observers)\r\n        observer.added(this, element);\r\n}\r\n```\r\n所有的外部调用都在同步块之外，也就是开放式调用（open call）。除了避免故障的产生，还可以大大的提高并发。\r\n#### 在同步块中尽可能的少操作\r\n   如果需要进行大量操作，可以考虑把这些操作移出同步块。\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}