<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Effetive java by whyDK37</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Effetive java</h1>
      <h2 class="project-tagline"></h2>
      <a href="https://github.com/whyDK37/note" class="btn">View on GitHub</a>
      <a href="https://github.com/whyDK37/note/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/whyDK37/note/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h2>
<a id="concurrency-同步" class="anchor" href="#concurrency-%E5%90%8C%E6%AD%A5" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>concurrency 同步</h2>

<h3>
<a id="avoid-excessive-synchronization-避免过度使用synchronization" class="anchor" href="#avoid-excessive-synchronization-%E9%81%BF%E5%85%8D%E8%BF%87%E5%BA%A6%E4%BD%BF%E7%94%A8synchronization" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>avoid excessive synchronization 避免过度使用synchronization</h3>

<p>Here is an example,which implements an observable set wrapper.It allow clients to
subscribe to notifications when elements are added to the set.this is the <em>Observer</em> pattern.
for brevity`s, the class does not provide notifications when elements are removed from the set.</p>

<p>这有一个观察着封装的set，它允许客户端订阅添加元素的通知，为了简介，没有提供移出元素的通知。</p>

<p>Observers subscribe to notifications by invoking the addObserver method and unsubscribe by invoking
the removeObserver method. In both cases, an instance of the <em>callback</em> interface is passed to the method.</p>

<p>观察者订阅调用addObserver，取消订阅调用removeObserver，两种操作的参数都回调接口。</p>

<pre><code>
import java.util.*;

/**
 * Created by why on 10/23/2016.
 */
public class ObservableSet0&lt;E&gt; extends HashSet&lt;E&gt; {
    public ObservableSet0(Set&lt;E&gt; set) {
        super(set);
    }

    private final List&lt;SetObserver&lt;E&gt;&gt; observers = new ArrayList&lt;SetObserver&lt;E&gt;&gt;();

    public void addObserver(SetObserver&lt;E&gt; observer) {
        synchronized (observers) {
            observers.add(observer);
        }
    }

    public boolean removeObserver(SetObserver&lt;E&gt; observer) {
        synchronized (observers) {
            return observers.remove(observer);
        }
    }

    private void notifyElementAdded(E element) {
        synchronized (observers) {
            for (SetObserver&lt;E&gt; observer : observers)
                observer.added(this, element);
        }
    }

    @Override
    public boolean add(E element) {
        boolean added = super.add(element);
        if (added)
            notifyElementAdded(element);
        return added;
    }

    @Override
    public boolean addAll(Collection&lt;? extends E&gt; c) {
        boolean result = false;
        for (E element : c)
            result |= add(element); // calls notifyElementAdded
        return result;
    }

    public static void main(String[] args) {
        ObservableSet0&lt;Integer&gt; set = new ObservableSet0&lt;Integer&gt;(new HashSet&lt;Integer&gt;());
        set.addObserver(new SetObserver&lt;Integer&gt;() {
            public void added(ObservableSet0&lt;Integer&gt; s, Integer e) {
                System.out.println(e);
            }
        });
        for (int i = 0; i &lt; 100; i++)
            set.add(i);
    }

    static class SetObserver&lt;E&gt; {
        public void added(ObservableSet0&lt;E&gt; es, E element) {
        }
    }
}

</code></pre>

<p>The result will print 0 through 99.Now let`s try something els.Suppose we replace the addObserver call with one that
passes an observer that prints the Integer value that was added to the set and removes itself if the value is 23.</p>

<p>结果是打印0-99。我们试着做一些其他事，添加一个订阅者，打印数字，并在数字是23的时候移出自己。</p>

<pre><code>import java.util.*;

/**
 * caes an  java.util.ConcurrentModificationException
 * Changing ArrayList to CopyOnWriteArrayList can solve this problem
 * &lt;p&gt;
 * Created by why on 10/23/2016.
 */
public class ObservableSet1&lt;E&gt; extends HashSet&lt;E&gt; {
    public ObservableSet1(Set&lt;E&gt; set) {
        super(set);
    }

    // fixme 2016-10-23 CopyOnWriteArrayList can solve this problem
    private final List&lt;SetObserver&lt;E&gt;&gt; observers = new ArrayList&lt;SetObserver&lt;E&gt;&gt;();

    public void addObserver(SetObserver&lt;E&gt; observer) {
        synchronized (observers) {
            observers.add(observer);
        }
    }

    public boolean removeObserver(SetObserver&lt;E&gt; observer) {
        synchronized (observers) {
            return observers.remove(observer);
        }
    }

    private void notifyElementAdded(E element) {
        synchronized (observers) {
            for (SetObserver&lt;E&gt; observer : observers)
                observer.added(this, element);
        }
    }

    @Override
    public boolean add(E element) {
        boolean added = super.add(element);
        if (added)
            notifyElementAdded(element);
        return added;
    }

    @Override
    public boolean addAll(Collection&lt;? extends E&gt; c) {
        boolean result = false;
        for (E element : c)
            result |= add(element); // calls notifyElementAdded
        return result;
    }

    public static void main(String[] args) {
        ObservableSet1&lt;Integer&gt; set = new ObservableSet1&lt;Integer&gt;(new HashSet&lt;Integer&gt;());
        set.addObserver(new SetObserver&lt;Integer&gt;() {
            public void added(ObservableSet1&lt;Integer&gt; s, Integer e) {
                System.out.println(e);
                if (e == 23) {
                    set.removeObserver(this);
                }
            }
        });
        for (int i = 0; i &lt; 100; i++)
            set.add(i);
    }

    static class SetObserver&lt;E&gt; {
        public void added(ObservableSet1&lt;E&gt; es, E element) {
        }
    }
}

</code></pre>

<p>You might expect the program to print the numbers 0 through 23.But you get an unexpected <em>ConcurrentModificationException</em>.
The problem is that notifyElementAdded is in the process of iterating over the observers list when it invokes the observer`s
added method.he iteration in the notifyElementAddded method is in a synchronized block to prevent concurrent modification,
but is does not prevent the iterating thread itself from calling back into the observable set and modifying its observers list.</p>

<p>Now let`s try something odd:Write an observer that attempts to unsubscribe, but instead of calling removeObserver directly,
it engages the services of another thread to do the deed.This observer uses an executor service.</p>

<pre><code>
import java.util.*;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * dead lock
 * &lt;p&gt;
 * This time we don’t get an exception; we get a deadlock. The background thread
 * calls s.removeObserver, which attempts to lock observers, but it can’t acquire
 * the lock, because the main thread already has the lock. All the while, the main
 * thread is waiting for the background thread to finish removing the observer, which
 * explains the deadlock.
 * Created by why on 10/23/2016.
 */
public class ObservableSet2&lt;E&gt; extends HashSet&lt;E&gt; {
    public ObservableSet2(Set&lt;E&gt; set) {
        super(set);
    }

    private final List&lt;SetObserver&lt;E&gt;&gt; observers = new ArrayList&lt;SetObserver&lt;E&gt;&gt;();

    public void addObserver(SetObserver&lt;E&gt; observer) {
        synchronized (observers) {
            observers.add(observer);
        }
    }

    public boolean removeObserver(SetObserver&lt;E&gt; observer) {
        synchronized (observers) {
            return observers.remove(observer);
        }
    }

    private void notifyElementAdded(E element) {
        synchronized (observers) {
            for (SetObserver&lt;E&gt; observer : observers)
                observer.added(this, element);
        }
    }

    @Override
    public boolean add(E element) {
        boolean added = super.add(element);
        if (added)
            notifyElementAdded(element);
        return added;
    }

    @Override
    public boolean addAll(Collection&lt;? extends E&gt; c) {
        boolean result = false;
        for (E element : c)
            result |= add(element); // calls notifyElementAdded
        return result;
    }

    public static void main(String[] args) {
        ObservableSet2&lt;Integer&gt; set = new ObservableSet2&lt;Integer&gt;(new HashSet&lt;Integer&gt;());
        set.addObserver(new SetObserver&lt;Integer&gt;() {
            public void added(ObservableSet2&lt;Integer&gt; s, Integer e) {
                System.out.println(e);
                if (e == 23) {
                    ExecutorService executor =
                            Executors.newSingleThreadExecutor();
                    final SetObserver&lt;Integer&gt; observer = this;
                    try {
                        executor.submit(new Runnable() {
                            public void run() {
                                s.removeObserver(observer);
                            }
                        }).get();
                    } catch (ExecutionException ex) {
                        throw new AssertionError(ex.getCause());
                    } catch (InterruptedException ex) {
                        throw new AssertionError(ex.getCause());
                    } finally {
                        executor.shutdown();
                    }
                }
            }
        });
        for (int i = 0; i &lt; 100; i++)
            set.add(i);
    }

    static class SetObserver&lt;E&gt; {
        public void added(ObservableSet2&lt;E&gt; es, E element) {
        }
    }
}

</code></pre>

<p>This time we don`t get an exception,we get a deadlock.The background thread calls s.removeObserve,which attempts to lock
 observers,bug it can not acquire the lock,because the main thread already has the lock.All the while,the main thread is
 waiting for the background thread to finish removing the observer,which explains the deadlock.</p>

<p>这是一个人为的例子，因为我们没有必要再观察者中时候线程池。</p>

<p>解决上面两种情况引起的问题，我们可以把方法调用移出同步块。就上面的例子，我们可以在notifyElementAdded方法中生产observer的快照，然后可以
安全的去掉锁。这样上面两个例子都会完美运行。</p>

<pre><code>private void notifyElementAdded(E element) {
    List&lt;SetObserver&lt;E&gt;&gt; snapshot = null;
    synchronized(observers) {
        snapshot = new ArrayList&lt;SetObserver&lt;E&gt;&gt;(observers);
    }
    for (SetObserver&lt;E&gt; observer : snapshot)
        observer.added(this, element);
}
</code></pre>

<p>事实上有更好的方法，java 1.5提供的concurrent collection中的CopyOnWriteArrayList，就是为这个目的而生。当元素改变时，他会新复制一份
完整的数据，对其他情况而言这种操作可能非常粗暴，但是非常适合保存observer，因为他改变的情况比较少。</p>

<pre><code>private final List&lt;SetObserver&lt;E&gt;&gt; observers = new CopyOnWriteArrayList&lt;SetObserver&lt;E&gt;&gt;();
public void addObserver(SetObserver&lt;E&gt; observer) {
    observers.add(observer);
}
public boolean removeObserver(SetObserver&lt;E&gt; observer) {
    return observers.remove(observer);
}
private void notifyElementAdded(E element) {
    for (SetObserver&lt;E&gt; observer : observers)
        observer.added(this, element);
}
</code></pre>

<p>所有的外部调用都在同步块之外，也就是开放式调用（open call）。除了避免故障的产生，还可以大大的提高并发。</p>

<h4>
<a id="在同步块中尽可能的少操作" class="anchor" href="#%E5%9C%A8%E5%90%8C%E6%AD%A5%E5%9D%97%E4%B8%AD%E5%B0%BD%E5%8F%AF%E8%83%BD%E7%9A%84%E5%B0%91%E6%93%8D%E4%BD%9C" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>在同步块中尽可能的少操作</h4>

<p>如果需要进行大量操作，可以考虑把这些操作移出同步块。</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/whyDK37/note">Effetive java</a> is maintained by <a href="https://github.com/whyDK37">whyDK37</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
